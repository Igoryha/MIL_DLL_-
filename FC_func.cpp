/*============================================================================
                      Copyright ГосНИИАС
..............................................................................
ПРОЕКТ       : модель изд. 101КС-В
..............................................................................
ИМЯ МОДУЛЯ   : Вспомогательные функции для кодировки и декодировки данных,
               идущих по линии Fibre Channel из изд.101КС-В
ИМЯ ФАЙЛА    : FC_func.c
АББРЕВИАТУРА : fc
АВТОР        : Мазур Е.Ф.
..............................................................................
ОПИСАНИЕ МОДУЛЯ: Данный модуль содержит вспомогательные функции, используемые
                 при запаковке и распаковке данных, передаваемых
                 по Fibre Channel в БЦВМ из изд. 101КС-В
..............................................................................
ФУНКЦИИ:
      Список экспортируемых функций модуля
         fcCodInt
         fcCodBit
         fcCodReal
         fcDecodInt
         fcDecodUInt
         fcDecodBit
         fcDecodReal
      Список внутренних функций модуля
         fcInversWord
         fcCreateMask

==============================================================================
*/

#define FCfunc
#include "FC_func.h"

/*--------------------------------------------------------------------------*/
/*                Константы и макросы                                       */

// Значения, соответствующие разрядам слов, принятым в линии Fibre Channel
// (кодировка по ГОСТ ??: левый бит (старший) - 01-й, правый (младший)- 32-й).
// Всегда номер левого бита должен быть меньше номера правого бита !!!

/*--------------------------------------------------------------------------*/
/*                Типы                                                      */
/*   нет                                                                    */

/*--------------------------------------------------------------------------*/
/*                Переменные                                                */
/*   нет                                                                    */

/*--------------------------------------------------------------------------*/
/*         Заголовки локальных функций, описанных в данном модуле           */

void fcInversWord
(
   int BitLeft,
   int BitRight,
   Word32* W
);

Word32 fcCreateMask
(
   int BitLeft,
   int BitRight
);

/*--------------------------------------------------------------------------*/
/*              Экспортируемые функции                                      */

/*
==============================================================================
ИМЯ ФУНКЦИИ: fcCodInt
..............................................................................
ОПИСАНИЕ   : Функция кодирует целое число в указанный диапазон
             разрядов.32-разрядного слова в формат линии Fibre Channel
..............................................................................
*/
void fcCodInt
(
   // Входные данные
   int      Sign,
   int      bitLeft,
   int      bitRight,
   int      Value,
   // Входы-Выходы
   Word32*  W
)
{

   Word32 Code = (Word32)(Value) << (32 - bitRight);
   Word32 Mask;

   if( Sign == 1 )
   {
      Mask = fcCreateMask( bitLeft-1, bitRight );
   }
   else
   {
      Mask = fcCreateMask( bitLeft, bitRight );
   }

   *W = (Code & Mask) | (*W & (~Mask));

} // fcCodInt


/*
==============================================================================
ИМЯ ФУНКЦИИ: fcCodBit
..............................................................................
ОПИСАНИЕ   : Функция кодирует один бит (значения 0 или 1) в указанный разряд
             32-разрядного слова в формат линии Fibre Channel
..............................................................................
*/
void fcCodBit
(
   // Входные данные
   int          bitNum,
   unsigned int Discret,
   // Входы-Выходы
   Word32*      W
)
{

   Word32 Mask = 0x00000001UL << ( 32 - bitNum );
   Word32 Code = Discret << ( 32 - bitNum );

   *W = (Code & Mask) | (*W & (~Mask));

} // fcCodBit


/*
==============================================================================
ИМЯ ФУНКЦИИ: fcCodReal
..............................................................................
ОПИСАНИЕ   : Функция кодирует вещественное число в указанный
             диапазон разрядов.32-разрядного слова с определенной ЦСР в формат
             линии Fibre Channel
..............................................................................
*/
void fcCodReal
(
   // Входные данные
   int      Sign,
   int      bitLeft,
   int      bitRight,
   double   Value,
   double   MSB,
   // Входы-Выходы
   Word32* W
)
{

   Word32 Mask;
   Word32 W_MSB = 0x00000001UL << ( 32 - bitLeft );
   Word32 Code  = (Word32)(Value * ( W_MSB / MSB ));

   if( Sign == 0 )
   // Маска для положительных чисел (без знака)
   {
      Mask = fcCreateMask( bitLeft, bitRight );
   }
   else
   // Маска для отрицательных чисел со знаком
   {
      Mask = fcCreateMask( bitLeft-1, bitRight );
   }

   *W = (Code & Mask) | (*W & (~Mask));

} // fcCodReal


/*
==============================================================================
ИМЯ ФУНКЦИИ: fcDecodInt
..............................................................................
ОПИСАНИЕ   : Функция декодирует указанный диапазон разрядов.32-разрядного
             слова из формата линии Fibre Channel в целое число
..............................................................................
*/
void fcDecodInt
(
   // Входные данные
   int     Sign,
   int     bitLeft,
   int     bitRight,
   Word32  W,
   // Выходные данные
   int*    Value
)
{

   Word32 Mask;
   Word32 Mask0;
   Word32 W1;
   Word32 W2;

   unsigned int Sign_1 = 0;
   unsigned int Mask2;

   if( Sign == 1 )
   {

      // Декодировка знаковых целых чисел
      Mask0 = fcCreateMask( bitLeft-1, bitRight );
      W1 = ( W & Mask0 ) >> ( 32 - bitRight );

      Mask2 = 0x00000001UL << ( 32 - (bitLeft-1) );
      Sign_1 = W & ( 0x00000001UL << ( 32 - (bitLeft-1) ) );

      // Если есть 1 в знаковом разряде
      if( Mask2 == Sign_1 )
      {
         // Декодировка отрицательных целых чисел
         Mask = ~( (0xffffffffUL & Mask0) >> ( 32 - bitRight ) );
         W2 = Mask | W1;
      }
      else
      {
         // Декодировка положительных целых чисел
         W2 = W1;
      }
      *Value = (int)( W2 );
   }
   else
   {
      // Декодировка беззнаковых целых чисел
      Mask = fcCreateMask( bitLeft, bitRight );
      *Value = (int)(( W & Mask ) >> ( 32 - bitRight ) );
   }

} // fcDecodInt
/*
==============================================================================
ИМЯ ФУНКЦИИ: fcDecodInt
..............................................................................
ОПИСАНИЕ   : Функция декодирует указанный диапазон разрядов.32-разрядного
             слова из формата линии Fibre Channel в целое число
..............................................................................
*/
/*
==============================================================================
ИМЯ ФУНКЦИИ: fcDecodUChar
..............................................................................
ОПИСАНИЕ   : Функция декодирует указанный диапазон разрядов.32-разрядного
             слова из формата линии Fibre Channel в целое число
..............................................................................
*/
void fcDecodUChar
(
   // Входные данные
   int     Sign,
   int     bitLeft,
   int     bitRight,
   Word32  W,
   // Выходные данные
   unsigned char*    Value
)
{

   Word32 Mask;
   Word32 Mask0;
   Word32 W1;
   Word32 W2;
   int tmp;
   unsigned int Sign_1 = 0;
   unsigned int Mask2;

   if( Sign == 1 )
   {

      // Декодировка знаковых целых чисел
      Mask0 = fcCreateMask( bitLeft-1, bitRight );
      W1 = ( W & Mask0 ) >> ( 32 - bitRight );

      Mask2 = 0x00000001UL << ( 32 - (bitLeft-1) );
      Sign_1 = W & ( 0x00000001UL << ( 32 - (bitLeft-1) ) );

      // Если есть 1 в знаковом разряде
      if( Mask2 == Sign_1 )
      {
         // Декодировка отрицательных целых чисел
         Mask = ~( (0xffffffffUL & Mask0) >> ( 32 - bitRight ) );
         W2 = Mask | W1;
      }
      else
      {
         // Декодировка положительных целых чисел
         W2 = W1;
      }
      tmp = (int)( W2 );
	  *Value = (unsigned char)tmp;
   }
   else
   {
      // Декодировка беззнаковых целых чисел
      Mask = fcCreateMask( bitLeft, bitRight );
	  tmp = (int)(( W & Mask ) >> ( 32 - bitRight ) );
	  *Value = (unsigned char)tmp;
   }

} // fcDecodUChar


/*
==============================================================================
ИМЯ ФУНКЦИИ: fcDecodUInt
..............................................................................
ОПИСАНИЕ   : Функция декодирует заданный диапазон разрядов.32-разрядного
             слова из формата линии Fibre Channel в беззнаковое целое число
..............................................................................
*/
void fcDecodUInt
(
   // Входные данные
   int		     Sign,
   int           bitLeft,
   int           bitRight,
   Word32        W,
   // Выходные данные
   unsigned int* Value
)
{

   Word32 Mask = fcCreateMask( bitLeft, bitRight );

   *Value = (unsigned int)(( W & Mask ) >> ( 32 - bitRight ) );

} // fcDecodUInt


/*
==============================================================================
ИМЯ ФУНКЦИИ: DecodBit
..............................................................................
ОПИСАНИЕ   : Функция декодирует один бит (значения 0 или 1) из указанного
             разряда.32-разрядного слова в формате линии Fibre Channel
..............................................................................
*/
void fcDecodBit
(
   // Входные данные
   int           bitNum,
   Word32        W,
   // Выходные данные
   unsigned int* Discret
)
{

   Word32 Mask = 0x00000001UL << ( 32 - bitNum );

   *Discret = (unsigned int)(( W & Mask ) >> ( 32 - bitNum ));

} // fcDecodBit


/*
==============================================================================
ИМЯ ФУНКЦИИ: fcDecodReal
..............................................................................
ОПИСАНИЕ  : Функция декодирует указанный диапазон разрядов 32-разрядного
            слова из формата линии Fibre Channel в вещественное число с учетом
            заданной цены старшего разряда (ЦСР).
..............................................................................
*/
void fcDecodReal
(
   // Входные данные
   int      Sign,
   int      bitLeft,
   int      bitRight,
   double   MSB,
   Word32   W,
   // Выходные данные
   double*  Value
)
{

   Word32 Mask;
   Word32 W_MSB;
   Word32 W1;

   if( Sign == 0 )
   // Маска для положительных чисел (без знака)
   {
      Mask = fcCreateMask( bitLeft, bitRight );
      W1 = ( W & Mask ) << ( bitLeft - 1 );
      W_MSB = 0x80000000UL;

      *Value = ((double)( W1 )) / W_MSB * MSB;

   }
   else
   // Маска для вещественных чисел со знаком
   {
      Mask = fcCreateMask( bitLeft-1, bitRight );
      W1 = ( W & Mask ) << ( bitLeft - 2 );
      W_MSB = 0x40000000UL;

      *Value = ((double)((int)( W1 ))) / W_MSB * MSB;

   }

} // fcDecodReal


/*--------------------------------------------------------------------------*/
/*                  Внутренние функции                                      */

/*
==============================================================================
ИМЯ ФУНКЦИИ: fcInversWord
..............................................................................
ОСНОВАНИЕ ДЛЯ РАЗРАБОТКИ :
..............................................................................
ОПИСАНИЕ   : Функция переворачивает указанный диапазон разрядов.входного 32-
             разрядного слова и возвращает этот же параметр в измененном виде
..............................................................................
*/
void fcInversWord
(
   // Входные данные
   int   BitLeft,
   int   BitRight,
   // Входы-Выходы
   Word32* W
)
{
   Word32 MaskIn  = 0x00000001UL << (32 - BitRight);
   Word32 MaskOut = 0x00000001UL << (32 - BitLeft);

   int N = BitRight - BitLeft;
   int Number = N + 1;
   int i;
   Word32 W_auxi = *W;

   for(i=0; i<Number; i++)
   {
      Word32 Bits;
      Bits = *W & MaskIn;

      if( (N - 2*i) >= 0 )
      {
         W_auxi = (W_auxi & (~MaskOut)) | (Bits << (N - 2*i));
      }
      else
      {
         W_auxi = (W_auxi & (~MaskOut)) | (Bits >> (2*i - N));
      }

      MaskIn = MaskIn << 1;
      MaskOut = MaskOut >> 1;
   }

   *W = W_auxi;

} // fcInversWord


/*
==============================================================================
ИМЯ ФУНКЦИИ: fcCreateMask
..............................................................................
ОСНОВАНИЕ ДЛЯ РАЗРАБОТКИ :
..............................................................................
ОПИСАНИЕ : Функция создает маску для выбора группы бит из 32-разрядного слова
..............................................................................
*/
Word32 fcCreateMask
(
   // Входные данные
   int BitLeft,
   int BitRight
)
{
   Word32 Mask    = 0x00000001UL << (32 - BitRight);
   Word32 MaskOut = 0x00000000UL;
   int i;

   for( i=0; i<(BitRight - BitLeft)+1; i++ )
   {
      MaskOut = MaskOut | Mask;
      Mask = Mask << 1;
   }
   return( MaskOut );

} // fcCreateMask

/*==========================================================================*/